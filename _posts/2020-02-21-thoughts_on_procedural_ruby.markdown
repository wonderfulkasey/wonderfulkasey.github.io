---
layout: post
title:      "Thoughts on Procedural Ruby "
date:       2020-02-21 15:29:25 +0000
permalink:  thoughts_on_procedural_ruby
---


Procedural Ruby differs from Object Oriented Ruby (OO Ruby) by how the code organizes the information given - also, we use all the information from Procedural Ruby to ‘guide’ our way of thinking, even if we are using different words or explanations. This lends itself to the fact that logic is logic, even when the words involved have been moved around.

Procedural Ruby has it’s information (or, data) separately from the instructions on how to use it. Written down it sounds like it would be simpler than Object Oriented Ruby - however, in practice, Procedural Ruby becomes complicated and messy. 

It creates code that consistently needs to be changed (especially the ‘handing off’ of titles - after all, you can only give each word one definition this way) if you want it to be effective. While it is already a hassle for one programmer, it can lead to disastrous results if tried in a team situation. (This is a good time for another reminder - comment out your code! Future collaborators, and future you, will be very grateful!)

Since I have given you the dirt on Procedural Ruby, let’s talk about the better method in more detail - our hero of the day, Object Oriented Ruby.

Currently, the assignments that I have been completing are to be done that way, as it creates clearer code. One such example is our Tic Tac Toe game, which took me the better part of an afternoon to complete, that would have been made much more difficult if I had to go back and keep redefining objects.

In our first section of the software engineer programming course, we learned about ‘basic’ functions of code - hashes, booleans, if statements. From this we learned that one of the hardest parts of programming is that we have to see the world through the program’s eyes - which, more often than not, means simplifying whatever it is we are trying to communicate. 

The computer itself is like a rock that now holds some electricity and a few cool fonts - while it is complicated to construct it, it is very easy to break it. Rome may have not been built in a day, but it sure as hell burned in one.

Most of the functions of Procedural Ruby follow ‘simple’ logic guidelines - if A happens, then B occurs. It is simple in the way that it does not take paragraphs upon paragraphs to write, yet complicated due to the fact that for a sentence so basic, we have to understand all the working parts.

Another such example is the “if”, “else”, “elsif”, which works a lot like my example above about the “if/then” statements. In college, I took a logic class while chasing a philosophy degree, and I thought surely, it mustn’t be THAT hard - it’s logic! Well, like that class on a whole, the Procedural Ruby “if / else / elsif” is more complicated the farther you proceed with it. 

